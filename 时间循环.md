# 浏览器的进程模型

## 何为进程？

程序为了运行需要的专属内存空间，可以把这块空间简单理解为进程，
每个程序运行至少需要一个进程，进程之间相互独立的，即使要通信也需要双方同意

## 什么是线程？

计算机中的一个执行单元，它是进程的基本调度单位。每个进程至少包含一个线程，通常称为“主线程”。线程是程序执行的最小单位，而进程是程序执行的最基本单位。
通常主线程会启动更多的线程来执行执行程序，所有一个进程可以包含多个线程

例： 王者荣耀程序
主线程： 显示登录页面等。
游戏线程： 监听用户的点击，响应用户的操作。
网络线程： 响应网络请求内容，人物移动的位置等

## 浏览器有哪些进程和线程？

浏览器是一个多进程多线程的应用程序。浏览器的内部极其复杂，为了避免互相影响，减少连环崩溃的几率。当浏览器启动时，他会自动启动多个进程。

浏览器进程：
负责标签页面的展示，用户交互，子进程的管理（网络进程，渲染进程，都是有浏览器进程，启动起来的）等，浏览器进程内部会启动多个线程处理不同的任务。

网络进程：
负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。

渲染进程：
渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。

默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。

## 渲染主线程如何工作（最忙的线程）

1. 解析 HTML
2. 解析 CSS
3. 样式计算
4. 布局
5. 处理图层
6. 每秒把页面画 60 次
7. 执行 全局 js code
8. 执行事件处理函数
9. 执行计时器的回调函数

### 为什么渲染进程不适合开多个线程来处理

要处理很多任务时，主线程遇到的最大问题是：如何调度任务。
如：
我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？
我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？
浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？

### 渲染主线程想出了一个绝妙的主意来处理这个问题：排队

主线程： 处理正在执行的任务
消息队列： 其他线程处理的需要执行的任务

1. 在最开始的时候，渲染主进程会进入一个无限循环
2. 每次循环都会去看消息队列中是否有任务存在，如果有，取出第一个任务执行，执行完后进入下一个循环。如果没有进入休眠
3. 其他所有线程（包括其他进程的线程）可以随时的向消息队列中添加任务，新的任务会排在队列的末尾，在添加任务时，如果主线程处于休眠状态，则会将其唤醒，循环执行任务。
   这样就可以让那个任务有条理的持续进行下去。

### 什么是异步

在代码执行的过程中，遇到不能立即拿到结果的任务，例如：

1. 计时器完成时需要执行的任务 - setTimeOut， setInTerVal
2. 网络通信后需要执行的任务 - XHR, Fetch
3. 用户操作后需要执行的任务 addEventListener
   如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」

渲染主线程承担着极其重要的工作，无论如何都不能阻塞！
使用异步的方式，渲染主线程永不阻塞

### 面试题： 如何理解 js 中的异步

js 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中的，而渲染主线程只有一个。
渲染主线程主要承担着很多工作，例如： 渲染页面，执行 JS 代码，都是在其中执行的。
如果使用同步的方式，就极有可能导致主线程阻塞。从而导致消息队列中的很多任务无法得到执行，这样一来，一方面导致繁忙的主线程白白的消耗时间。 另一方面导致页面无法及时更新，给用户造成卡死现象。
所以浏览器都采用异步的方式来避免。 具体做法是，当遇到一些任务时，例如： 计时器，网络，时间监听， 主线程会交给其他线程处理，自身立即结束任务的执行，转而执行其他的任务代码。当其他任务完成时，将事先传递的回调函数包装成任务，假如到消息队列的尾端。等待主主线程的调度执行。
在这种异步的情况下，主线程永远不会阻塞，从而最大限度的保证主线程的通畅运行。

### 任务有优先级吗》？

任务没有优先级， 在消息队列中就是先进先出
但是消息队列有有优先级

根据 W3C 的解释：
每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。
在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行

## 面试题： 阐述一下 JS 的事件循环

事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。

在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。

过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。

根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。

面试题： JS 中的计时器能做到精确计时吗？为什么？
1。 计算机硬件没有原子钟，无法做到精确计时
2。 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差
3。 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差
4． 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差
